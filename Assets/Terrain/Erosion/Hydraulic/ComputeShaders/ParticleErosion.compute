#pragma kernel CSMain

#include "Includes/Direction.compute"
#include "Includes/Particle.compute"

RWTexture2D<float> map;
StructuredBuffer<Particle> initialParticles;
StructuredBuffer<int2> brushIndices;
StructuredBuffer<float> brushWeights;

AppendStructuredBuffer<Particle> outgoingParticles;

RWTexture2D<float4> DebugOutput;
bool enableDebugOutput;

int mapSizeWithBorder;
int brushLength;
int borderSize;
#define mapResolution (mapSizeWithBorder - 2 * borderSize)

int maxLifetime;
float inertia;
float sedimentCapacityFactor;
float minSedimentCapacity;
float depositSpeed;
float erodeSpeed;

float evaporateSpeed;
float gravity;
float startSpeed;
float startWater;

float3 CalculateHeightAndGradient(float2 position)
{
    int2 coord = (int2) position;
    float2 cellOffset = position - (float2) coord;

    float heightNW = map[coord];
    float heightNE = map[coord + int2(1, 0)];
    float heightSW = map[coord + int2(0, 1)];
    float heightSE = map[coord + int2(1, 1)];

    float2 gradient = float2((heightNE - heightNW) * (1 - cellOffset.y) + (heightSE - heightSW) * cellOffset.y,
                             (heightSW - heightNW) * (1 - cellOffset.x) + (heightSE - heightNE) * cellOffset.x);
    
    float height = lerp(
        lerp(heightNW, heightNE, cellOffset.x),
        lerp(heightSW, heightSE, cellOffset.x),
        cellOffset.y
    );

    return float3(gradient.x, gradient.y, height);
}

bool HandleOutgoingParticle(float2 dropletPosition, float2 direction, float speed, float water, float sediment, int age, int haloResilience)
{
    bool isOutOfBoundsWest = dropletPosition.x < borderSize;
    bool isOutOfBoundsEast = dropletPosition.x >= mapSizeWithBorder - borderSize;
    bool isOutOfBoundsSouth = dropletPosition.y < borderSize;
    bool isOutOfBoundsNorth = dropletPosition.y >= mapSizeWithBorder - borderSize;

    if (!isOutOfBoundsNorth && !isOutOfBoundsEast && !isOutOfBoundsSouth && !isOutOfBoundsWest)
    {
        return false;
    }

    int exitDirection = GetExitDirection(isOutOfBoundsNorth, isOutOfBoundsEast, isOutOfBoundsSouth, isOutOfBoundsWest);

    float normalizedX = dropletPosition.x - borderSize;
    float normalizedY = dropletPosition.y - borderSize;
    float wrappedX = isOutOfBoundsWest ? mapResolution + dropletPosition.x : dropletPosition.x - (mapSizeWithBorder - borderSize);
    float wrappedY = isOutOfBoundsSouth ? mapResolution + dropletPosition.y : dropletPosition.y - (mapSizeWithBorder - borderSize);
    
    Particle op;
    op.pos = float2(0, 0);
    op.dir = direction;
    op.speed = speed;
    op.water = water;
    op.sediment = sediment;
    op.age = age + 1;
    op.status = exitDirection;
    op.haloResilience = haloResilience;

    switch (exitDirection)
    {
        case DIR_NORTH:
            op.pos = float2(dropletPosition.x, wrappedY);
            break;
        case DIR_NORTH_EAST:
            op.pos = float2(wrappedX, wrappedY);
            break;
        case DIR_EAST:
            op.pos = float2(wrappedX, dropletPosition.y);
            break;
        case DIR_SOUTH_EAST:
            op.pos = float2(wrappedX, wrappedY);
            break;
        case DIR_SOUTH:
            op.pos = float2(dropletPosition.x, wrappedY);
            break;
        case DIR_SOUTH_WEST:
            op.pos = float2(wrappedX, wrappedY);
            break;
        case DIR_WEST:
            op.pos = float2(wrappedX, dropletPosition.y);
            break;
        case DIR_NORTH_WEST:
            op.pos = float2(wrappedX, wrappedY);
            break;
    }
    
    outgoingParticles.Append(op);
    return true;
}


[numthreads(1024, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint numParticles, stride;
    initialParticles.GetDimensions(numParticles, stride);

    if (id.x >= numParticles)
    {
        return;
    }
    
    Particle p_initial = initialParticles[id.x];
    float2 dropletPosition = p_initial.pos;
    float2 direction = p_initial.dir;
    float speed = p_initial.speed;
    float water = p_initial.water;
    float sediment = p_initial.sediment;
    
    int haloStepsLeft = p_initial.haloResilience;
    bool wasTransferred = false;

    for (int lifetime = p_initial.age; lifetime < maxLifetime; lifetime++)
    {
        int2 nodePosition = (int2) dropletPosition;
        float2 cellOffset = dropletPosition - (float2) nodePosition;

        // Calculate droplet's height and direction of flow with bilinear interpolation of surrounding heights
        float3 heightAndGradient = CalculateHeightAndGradient(dropletPosition);
        direction = normalize((direction * inertia) - (heightAndGradient.xy * (1 - inertia)));
        dropletPosition += direction;
        
        // Stop if Particle stands still
        if (direction.x == 0 && direction.y == 0)
        {
            break;
        }

        float newHeight = CalculateHeightAndGradient(dropletPosition).z;
        float deltaHeight = newHeight - heightAndGradient.z;

        float sedimentCapacity = max(-deltaHeight * speed * water * sedimentCapacityFactor, minSedimentCapacity);
        
        if (sediment > sedimentCapacity || deltaHeight > 0)
        {
            float amountToDeposit = (deltaHeight > 0) ? min(deltaHeight, sediment) : (sediment - sedimentCapacity) * depositSpeed;
            sediment -= amountToDeposit;
            
            map[nodePosition] += amountToDeposit * (1 - cellOffset.x) * (1 - cellOffset.y);
            map[nodePosition + int2(1, 0)] += amountToDeposit * cellOffset.x * (1 - cellOffset.y);
            map[nodePosition + int2(0, 1)] += amountToDeposit * (1 - cellOffset.x) * cellOffset.y;
            map[nodePosition + int2(1, 1)] += amountToDeposit * cellOffset.x * cellOffset.y;
        }
        else
        {
            float amountToErode = min((sedimentCapacity - sediment) * erodeSpeed, -deltaHeight);
            
            for (int i = 0; i < brushLength; i++)
            {
                int2 erodeCoord = nodePosition + brushIndices[i];

                float weightedErodeAmount = amountToErode * brushWeights[i];
                float currentHeight = map[erodeCoord];
                float deltaSediment = (currentHeight < weightedErodeAmount) ? currentHeight : weightedErodeAmount;
                map[erodeCoord] -= deltaSediment;
                sediment += deltaSediment;
            }
        }

        speed = sqrt(max(0, speed * speed + deltaHeight * gravity));
        water *= (1 - evaporateSpeed);
        
        // Stop if Particle went out of bounds of the actual chunk and entered the halo zone
        bool isOutsideCoreChunk = dropletPosition.x < borderSize || dropletPosition.x >= mapSizeWithBorder - borderSize ||
                                  dropletPosition.y < borderSize || dropletPosition.y >= mapSizeWithBorder - borderSize;

        if (isOutsideCoreChunk)
        {
            haloStepsLeft--;
            if (haloStepsLeft < 0)
            {
                wasTransferred = true;
                if (HandleOutgoingParticle(dropletPosition, direction, speed, water, sediment, lifetime, p_initial.haloResilience))
                {
                    break;
                }
            }
        }
    }
    if (enableDebugOutput && !wasTransferred)
    {
        DebugOutput[dropletPosition] = float4(1, 0, 0, 1);
    }
}


