#pragma kernel CSMain

#include "Includes/Direction.compute"
#include "Includes/Particle.compute"

RWTexture2D<float> map;
StructuredBuffer<Particle> initialParticles;
StructuredBuffer<int2> brushIndices;
StructuredBuffer<float> brushWeights;

AppendStructuredBuffer<OutgoingParticle> outgoingParticlesN;
AppendStructuredBuffer<OutgoingParticle> outgoingParticlesW;
AppendStructuredBuffer<OutgoingParticle> outgoingParticlesS;
AppendStructuredBuffer<OutgoingParticle> outgoingParticlesE;
AppendStructuredBuffer<OutgoingParticle> outgoingParticlesCorners;

int mapSize;
int mapResolution;
int brushLength;
int borderSize;

int maxLifetime;
float inertia;
float sedimentCapacityFactor;
float minSedimentCapacity;
float depositSpeed;
float erodeSpeed;

float evaporateSpeed;
float gravity;
float startSpeed;
float startWater;

float3 CalculateHeightAndGradient(float2 position)
{
    int2 coord = (int2) position;
    float2 cellOffset = position - (float2) coord;

    float heightNW = map[coord];
    float heightNE = map[coord + int2(1, 0)];
    float heightSW = map[coord + int2(0, 1)];
    float heightSE = map[coord + int2(1, 1)];

    float2 gradient = float2((heightNE - heightNW) * (1 - cellOffset.y) + (heightSE - heightSW) * cellOffset.y,
                             (heightSW - heightNW) * (1 - cellOffset.x) + (heightSE - heightNE) * cellOffset.x);
    
    float height = lerp(
        lerp(heightNW, heightNE, cellOffset.x),
        lerp(heightSW, heightSE, cellOffset.x),
        cellOffset.y
    );

    return float3(gradient.x, gradient.y, height);
}

bool HandleOutgoingParticle(float2 dropletPosition, float2 direction, float speed, float water, float sediment, int lifetime)
{
    bool isOutOfBoundsWest = dropletPosition.x < borderSize;
    bool isOutOfBoundsEast = dropletPosition.x >= mapSize - borderSize;
    bool isOutOfBoundsNorth = dropletPosition.y < borderSize;
    bool isOutOfBoundsSouth = dropletPosition.y >= mapSize - borderSize;

    if (!isOutOfBoundsNorth && !isOutOfBoundsEast && !isOutOfBoundsSouth && !isOutOfBoundsWest)
    {
        return false;
    }

    int exitDirection = GetExitDirection(isOutOfBoundsNorth, isOutOfBoundsEast, isOutOfBoundsSouth, isOutOfBoundsWest);

    float normalizedX = dropletPosition.x - borderSize;
    float normalizedY = dropletPosition.y - borderSize;
    float wrappedX = isOutOfBoundsWest ? mapResolution + normalizedX : dropletPosition.x - (mapSize - borderSize);
    float wrappedY = isOutOfBoundsNorth ? mapResolution + normalizedY : dropletPosition.y - (mapSize - borderSize);
    
    OutgoingParticle op;
    op.particle.dir = direction;
    op.particle.speed = speed;
    op.particle.water = water;
    op.particle.sediment = sediment;
    op.particle.lifetime = lifetime;
    op.exitDirection = exitDirection;

    switch (exitDirection)
    {
        case DIR_NORTH_WEST:
            op.particle.pos = float2(wrappedX, wrappedY);
            outgoingParticlesCorners.Append(op);
            break;
        case DIR_NORTH_EAST:
            op.particle.pos = float2(wrappedX, wrappedY);
            outgoingParticlesCorners.Append(op);
            break;
        case DIR_SOUTH_WEST:
            op.particle.pos = float2(wrappedX, wrappedY);
            outgoingParticlesCorners.Append(op);
            break;
        case DIR_SOUTH_EAST:
            op.particle.pos = float2(wrappedX, wrappedY);
            outgoingParticlesCorners.Append(op);
            break;
        
        case DIR_NORTH:
            op.particle.pos = float2(normalizedX, wrappedY);
            outgoingParticlesN.Append(op);
            break;
        case DIR_EAST:
            op.particle.pos = float2(wrappedX, normalizedY);
            outgoingParticlesE.Append(op);
            break;
        case DIR_SOUTH:
            op.particle.pos = float2(normalizedX, wrappedY);
            outgoingParticlesS.Append(op);
            break;
        case DIR_WEST:
            op.particle.pos = float2(wrappedX, normalizedY);
            outgoingParticlesW.Append(op);
            break;
    }
    
    return true;
}


[numthreads(1024, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    Particle p_initial = initialParticles[id.x];
    
    float2 dropletPosition = p_initial.pos;
    float2 direction = p_initial.dir;
    float speed = p_initial.speed;
    float water = p_initial.water;
    float sediment = p_initial.sediment;

    for (int lifetime = p_initial.lifetime; lifetime < maxLifetime; lifetime++)
    {
        float3 heightAndGradient = CalculateHeightAndGradient(dropletPosition);
        
        direction = normalize((direction * inertia) - (heightAndGradient.xy * (1 - inertia)));
        dropletPosition += direction;

        int2 nodePosition = (int2)dropletPosition;
        float2 cellOffset = dropletPosition - (float2)nodePosition;

        if (direction.x == 0 && direction.y == 0)
        {
            break; 
        }
        if (HandleOutgoingParticle(dropletPosition, direction, speed, water, sediment, lifetime))
        {
            break;
        }

        float newHeight = CalculateHeightAndGradient(dropletPosition).z;
        float deltaHeight = newHeight - heightAndGradient.z; 
        float sedimentCapacity = max(-deltaHeight * speed * water * sedimentCapacityFactor, minSedimentCapacity);
        
        if (sediment > sedimentCapacity || deltaHeight > 0)
        {
            float amountToDeposit = (deltaHeight > 0) ? min(deltaHeight, sediment) : (sediment - sedimentCapacity) * depositSpeed;
            sediment -= amountToDeposit;
            
            map[nodePosition] += amountToDeposit * (1 - cellOffset.x) * (1 - cellOffset.y);
            map[nodePosition + int2(1, 0)] += amountToDeposit * cellOffset.x * (1 - cellOffset.y);
            map[nodePosition + int2(0, 1)] += amountToDeposit * (1 - cellOffset.x) * cellOffset.y;
            map[nodePosition + int2(1, 1)] += amountToDeposit * cellOffset.x * cellOffset.y;
        }
        else
        {
            float amountToErode = min((sedimentCapacity - sediment) * erodeSpeed, -deltaHeight);
            
            for (int i = 0; i < brushLength; i++)
            {
                int2 erodeCoord = nodePosition + brushIndices[i];

                float weightedErodeAmount = amountToErode * brushWeights[i];
                float currentHeight = map[erodeCoord];
                float deltaSediment = (currentHeight < weightedErodeAmount) ? currentHeight : weightedErodeAmount;
                map[erodeCoord] -= deltaSediment;
                sediment += deltaSediment;
            }
        }

        speed = sqrt(max(0, speed * speed + deltaHeight * gravity));
        water *= (1 - evaporateSpeed);
    }
}

