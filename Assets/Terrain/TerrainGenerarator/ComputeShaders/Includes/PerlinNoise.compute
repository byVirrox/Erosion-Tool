#ifndef PERLIN_NOISE_INCLUDED
#define PERLIN_NOISE_INCLUDED

#include "FbmParameters.compute"

float fade(float t)
{
    return t * t * t * (t * (t * 6 - 15) + 10);
}

float fade_deriv(float t)
{
    return 30.0 * t * t * (t * (t - 2.0) + 1.0);
}

float lerp(float t, float a, float b)
{
    return a + t * (b - a);
}

float perlin_grad(int hash, float x, float y)
{
    int h = hash & 15;
    float u = h < 8 ? x : y;
    float v = h < 4 ? y : h == 12 || h == 14 ? x : 0;
    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
}

float perlinNoise(float2 samplePoint)
{
    float fx = floor(samplePoint.x);
    float fy = floor(samplePoint.y);
    int ix = (int) fx;
    int iy = (int) fy;
    int X = ix & 255;
    int Y = iy & 255;
    samplePoint.x -= fx;
    samplePoint.y -= fy;
    float u = fade(samplePoint.x);
    float v = fade(samplePoint.y);
    int A = perm[X] + Y;
    int B = perm[X + 1] + Y;
    return lerp(v, lerp(u, perlin_grad(perm[A & 511], samplePoint.x, samplePoint.y), perlin_grad(perm[B & 511], samplePoint.x - 1, samplePoint.y)),
                   lerp(u, perlin_grad(perm[(A + 1) & 511], samplePoint.x, samplePoint.y - 1), perlin_grad(perm[(B + 1) & 511], samplePoint.x - 1, samplePoint.y - 1)));
}


float2 get_grad_vector_matched(int hash)
{
    int h = hash & 15;
    // Diese Logik spiegelt exakt wider, welche Vektoren aus der
    // Kombination von u, v, x und y in der Originalfunktion entstehen.
    switch (h)
    {
        case 0:
            return float2(1, 1);
        case 1:
            return float2(-1, 1);
        case 2:
            return float2(1, -1);
        case 3:
            return float2(-1, -1);
        case 4:
            return float2(1, 0);
        case 5:
            return float2(-1, 0);
        case 6:
            return float2(1, 0); // Ja, Duplikate sind hier korrekt
        case 7:
            return float2(-1, 0);
        case 8:
            return float2(0, 1);
        case 9:
            return float2(0, -1);
        case 10:
            return float2(0, 1);
        case 11:
            return float2(0, -1);
        case 12:
            return float2(1, 1);
        case 13:
            return float2(-1, 1);
        case 14:
            return float2(1, -1);
        case 15:
            return float2(-1, -1);
    }
    return float2(0, 0); // Sollte nie erreicht werden
}

float3 perlinNoise_and_Deriv(float2 samplePoint)
{
    // 1. Gitterzelle und lokale Koordinaten finden
    float2 fp = floor(samplePoint);
    int2 ip = int2(fp);
    float2 sp = samplePoint - fp; // Lokale Koordinaten (sx, sy)

    // 2. Hashes für die 4 Eckpunkte der Zelle berechnen (MIT KORREKTEM INDEXING!)
    int X = ip.x & 255;
    int Y = ip.y & 255;
    int A = perm[X] + Y;
    int B = perm[X + 1] + Y;

    // KORREKTUR: & 511 verwenden!
    int hash00 = perm[A & 511];
    int hash10 = perm[B & 511];
    int hash01 = perm[(A + 1) & 511];
    int hash11 = perm[(B + 1) & 511];

    // 3. Gradientenvektoren für alle 4 Ecken holen
    float2 grad00 = get_grad_vector_matched(hash00);
    float2 grad10 = get_grad_vector_matched(hash10);
    float2 grad01 = get_grad_vector_matched(hash01);
    float2 grad11 = get_grad_vector_matched(hash11);

    // 4. Einflusswerte (Skalarprodukte) berechnen
    float val00 = dot(grad00, sp);
    float val10 = dot(grad10, sp - float2(1.0, 0.0));
    float val01 = dot(grad01, sp - float2(0.0, 1.0));
    float val11 = dot(grad11, sp - float2(1.0, 1.0));

    // 5. Interpolationsgewichte und deren Ableitungen berechnen
    float u = fade(sp.x);
    float v = fade(sp.y);
    float dudx = fade_deriv(sp.x);
    float dvdy = fade_deriv(sp.y);

    // 6. Den Noise-Wert per bilinearer Interpolation berechnen
    float value = lerp(v, lerp(u, val00, val10), lerp(u, val01, val11));

    // 7. Die Ableitung zusammensetzen (analytisch korrekt)
    // Partielle Ableitung nach x
    float k0 = val10 - val00;
    float k1 = val11 - val01;
    float kx_part1 = dudx * lerp(v, k0, k1);
    float kx_part2 = lerp(v, lerp(u, grad00.x, grad10.x), lerp(u, grad01.x, grad11.x));
    
    // Partielle Ableitung nach y
    float k3 = lerp(u, val01, val11);
    float k4 = lerp(u, val00, val10);
    float ky_part1 = dvdy * (k3 - k4);
    float ky_part2 = lerp(v, lerp(u, grad00.y, grad10.y), lerp(u, grad01.y, grad11.y));
    
    float2 derivative = float2(kx_part1 + kx_part2, ky_part1 + ky_part2);
    return float3(value, derivative.x, derivative.y);
}


/**
float2 getGradientVector(int hash)
{
    int h = hash & 15;
    float u = h < 8 ? 1.0 : 0.0; // Vereinfachte Vektoren, oft ausreichend
    float v = h < 4 ? 1.0 : (h == 12 || h == 14 ? 1.0 : 0.0);
    return float2(((h & 1) == 0 ? u : -u), ((h & 2) == 0 ? v : -v));
}

float3 perlinNoised(float2 p)
{
    float2 fp = floor(p);
    int2 ip = (int2) fp;
    float2 fr = p - fp;

    // Interpolationsgewichte und deren Ableitungen
    float2 u = float2(fade(fr.x), fade(fr.y));
    float2 du = float2(fade_deriv(fr.x), fade_deriv(fr.y));

    // Hashes für die 4 Eckpunkte des Gitters
    int X0 = ip.x & 255, Y0 = ip.y & 255;
    int X1 = (X0 + 1) & 255, Y1 = (Y0 + 1) & 255;
    int h00 = perm[perm[X0] + Y0];
    int h10 = perm[perm[X1] + Y0];
    int h01 = perm[perm[X0] + Y1];
    int h11 = perm[perm[X1] + Y1];

    // Skalarprodukte (dot products) an den Ecken
    float g00 = perlin_grad(h00, fr.x, fr.y);
    float g10 = perlin_grad(h10, fr.x - 1, fr.y);
    float g01 = perlin_grad(h01, fr.x, fr.y - 1);
    float g11 = perlin_grad(h11, fr.x - 1, fr.y - 1);

    // Gradienten-Vektoren an den Ecken
    float2 grad00 = getGradientVector(h00);
    float2 grad10 = getGradientVector(h10);
    float2 grad01 = getGradientVector(h01);
    float2 grad11 = getGradientVector(h11);

    // Anwendung der Ketten- und Produktregel der Differentialrechnung
    float k0 = g00;
    float k1 = g10 - g00;
    float k2 = g01 - g00;
    float k3 = g00 - g10 - g01 + g11;

    // Finaler Wert (bilineare Interpolation der Skalarprodukte)
    float val = k0 + k1 * u.x + k2 * u.y + k3 * u.x * u.y;
    
    // Finale Ableitung
    float2 deriv = float2(
        du.x * (k1 + k3 * u.y) + u.x * (lerp(u.y, grad10.x, grad11.x) - lerp(u.y, grad00.x, grad01.x)),
        du.y * (k2 + k3 * u.x) + u.y * (lerp(u.x, grad01.y, grad11.y) - lerp(u.x, grad00.y, grad10.y))
    );

    return float3(val, deriv);
}



// GPU-friendly 2D hash function
float2 hash(float2 p)
{
    // https://www.shadertoy.com/view/4djSRW
    p = float2(dot(p, float2(127.1, 311.7)),
               dot(p, float2(269.5, 183.3)));
    return -1.0 + 2.0 * frac(sin(p) * 43758.5453123);
}

// Quintic interpolation function and its derivative
float4 quintic(float2 t)
{
    float2 t3 = t * t * t;
    float2 t4 = t3 * t;
    float2 t5 = t4 * t;
    return float4((6.0 * t5 - 15.0 * t4 + 10.0 * t3), // value
                  (30.0 * t4 - 60.0 * t3 + 30.0 * t * t)); // derivative
}

// 2D Perlin Noise with Analytical Derivative
// Returns float3(noise_value, dnoise/dx, dnoise/dy)
float3 perlin_deriv_2d(float2 p)
{
    float2 i = floor(p);
    float2 f = frac(p);

    // Get quintic interpolation weights and their derivatives
    float2 uv = quintic(f).xy;
    float2 duv = quintic(f).zw;

    // Gradients at the four corners of the cell
    float2 g00 = hash(i + float2(0.0, 0.0));
    float2 g10 = hash(i + float2(1.0, 0.0));
    float2 g01 = hash(i + float2(0.0, 1.0));
    float2 g11 = hash(i + float2(1.0, 1.0));

    // Distance vectors from corners to point
    float2 d00 = f - float2(0.0, 0.0);
    float2 d10 = f - float2(1.0, 0.0);
    float2 d01 = f - float2(0.0, 1.0);
    float2 d11 = f - float2(1.0, 1.0);

    // Dot products
    float v00 = dot(g00, d00);
    float v10 = dot(g10, d10);
    float v01 = dot(g01, d01);
    float v11 = dot(g11, d11);

    // Interpolate along x
    float n0 = lerp(v00, v10, uv.x);
    float n1 = lerp(v01, v11, uv.x);

    // Final noise value (interpolate along y)
    float noise_val = lerp(n0, n1, uv.y);

    // --- Partial Derivatives ---

    // Derivative w.r.t. x
    float dnx = lerp(lerp(g00.x, g10.x, uv.x), lerp(g01.x, g11.x, uv.x), uv.y) +
                lerp(v10 - v00, v11 - v01, uv.y) * duv.x;

    // Derivative w.r.t. y
    float dny = lerp(lerp(g00.y, g01.y, uv.y), lerp(g10.y, g11.y, uv.y), uv.x) +
                (n1 - n0) * duv.y;

    return float3(noise_val, dnx, dny);
}
**/

#endif