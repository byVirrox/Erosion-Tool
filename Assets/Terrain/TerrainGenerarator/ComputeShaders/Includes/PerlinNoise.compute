#ifndef PERLIN_NOISE_INCLUDED
#define PERLIN_NOISE_INCLUDED

#include "FbmParameters.compute"

float fade(float t)
{
    return t * t * t * (t * (t * 6 - 15) + 10);
}

float fade_deriv(float t)
{
    return 30.0 * t * t * (t * (t - 2.0) + 1.0);
}

float lerp(float t, float a, float b)
{
    return a + t * (b - a);
}

float perlin_grad(int hash, float x, float y)
{
    int h = hash & 15;
    float u = h < 8 ? x : y;
    float v = h < 4 ? y : h == 12 || h == 14 ? x : 0;
    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
}

float perlinNoise(float2 samplePoint)
{
    float fx = floor(samplePoint.x);
    float fy = floor(samplePoint.y);
    int ix = (int) fx;
    int iy = (int) fy;
    int X = ix & 255;
    int Y = iy & 255;
    samplePoint.x -= fx;
    samplePoint.y -= fy;
    float u = fade(samplePoint.x);
    float v = fade(samplePoint.y);
    int A = perm[X] + Y;
    int B = perm[X + 1] + Y;
    return lerp(v, lerp(u, perlin_grad(perm[A & 511], samplePoint.x, samplePoint.y), perlin_grad(perm[B & 511], samplePoint.x - 1, samplePoint.y)),
                   lerp(u, perlin_grad(perm[(A + 1) & 511], samplePoint.x, samplePoint.y - 1), perlin_grad(perm[(B + 1) & 511], samplePoint.x - 1, samplePoint.y - 1)));
}


float2 get_grad_vector_matched(int hash)
{
    int h = hash & 15;
    // Die Logik spiegelt wider, welche Vektoren aus der
    // Kombination von u, v, x und y in der Originalfunktion entstehen.
    switch (h)
    {
        case 0:
            return float2(1, 1);
        case 1:
            return float2(-1, 1);
        case 2:
            return float2(1, -1);
        case 3:
            return float2(-1, -1);
        case 4:
            return float2(1, 0);
        case 5:
            return float2(-1, 0);
        case 6:
            return float2(1, 0); 
        case 7:
            return float2(-1, 0);
        case 8:
            return float2(0, 1);
        case 9:
            return float2(0, -1);
        case 10:
            return float2(0, 1);
        case 11:
            return float2(0, -1);
        case 12:
            return float2(1, 1);
        case 13:
            return float2(-1, 1);
        case 14:
            return float2(1, -1);
        case 15:
            return float2(-1, -1);
    }
    return float2(0, 0); 
}

// --- Perlin Noise mit analytischer Ableitung (Inigo Quilez ) ---
// Gibt float3 zurück: (noiseValue, dnoise/dx, dnoise/dy)
float3 perlinNoise_deriv(float2 p) // p: samplePoint
{
    // 1. Integer- und Fraktionalteil finden
    float2 i = floor(p); // Integer part (ix, iy)
    float2 f = frac(p); // Fractional part (fx, fy)

    // 2. Glättungsfunktion und deren Ableitung berechnen (komponentenweise)
    float ux = fade(f.x); // Smoothed f.x
    float uy = fade(f.y); // Smoothed f.y
    float dux = fade_deriv(f.x); // Derivative df.x
    float duy = fade_deriv(f.y); // Derivative df.y

    // 3. Hashes und Gradientenvektoren für die 4 Ecken holen
    int X = (int) i.x & 255;
    int Y = (int) i.y & 255;
    int A = perm[X] + Y;
    int B = perm[X + 1] + Y;

    float2 g00 = get_grad_vector_matched(perm[A & 511]); // Gradient unten-links
    float2 g10 = get_grad_vector_matched(perm[B & 511]); // Gradient unten-rechts
    float2 g01 = get_grad_vector_matched(perm[(A + 1) & 511]); // Gradient oben-links
    float2 g11 = get_grad_vector_matched(perm[(B + 1) & 511]); // Gradient oben-rechts

    // 4. Skalarprodukte (Einflusswerte) der Ecken berechnen
    // v = dot(gradient, vector_from_corner_to_point)
    float v00 = dot(g00, f - float2(0.0, 0.0));
    float v10 = dot(g10, f - float2(1.0, 0.0));
    float v01 = dot(g01, f - float2(0.0, 1.0));
    float v11 = dot(g11, f - float2(1.0, 1.0));

    // 5. Noise-Wert durch bilineare Interpolation berechnen
    float value = lerp(uy, lerp(ux, v00, v10), lerp(ux, v01, v11));

    // 6. Analytische Ableitung berechnen (kombinierte Form, explizit komponentenweise)
    // Teil aus der Ableitung der Dot-Produkte (Interpolation der Gradienten-Komponenten)
    float grad_interp_x = lerp(uy, lerp(ux, g00.x, g10.x), lerp(ux, g01.x, g11.x));
    float grad_interp_y = lerp(uy, lerp(ux, g00.y, g10.y), lerp(ux, g01.y, g11.y));

    // Teil aus der Ableitung der Interpolationsgewichte
    float deriv_weight_x = dux * lerp(uy, v10 - v00, v11 - v01);
    float deriv_weight_y = duy * lerp(ux, v01 - v00, v11 - v10);

    // Gesamte Ableitung
    float2 derivative = float2(grad_interp_x + deriv_weight_x,
                                grad_interp_y + deriv_weight_y);

    return float3(value, derivative.x, derivative.y);
}

#endif