#ifndef PERLIN_NOISE_INCLUDED
#define PERLIN_NOISE_INCLUDED

#include "FbmParameters.compute"

float fade(float t)
{
    return t * t * t * (t * (t * 6 - 15) + 10);
}

float fade_deriv(float t)
{
    return 30.0 * t * t * (t * (t - 2.0) + 1.0);
}

float lerp(float t, float a, float b)
{
    return a + t * (b - a);
}

float perlin_grad(int hash, float x, float y)
{
    int h = hash & 15;
    float u = h < 8 ? x : y;
    float v = h < 4 ? y : h == 12 || h == 14 ? x : 0;
    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
}

float perlinNoise(float2 samplePoint)
{
    float fx = floor(samplePoint.x);
    float fy = floor(samplePoint.y);
    int ix = (int) fx;
    int iy = (int) fy;
    int X = ix & 255;
    int Y = iy & 255;
    samplePoint.x -= fx;
    samplePoint.y -= fy;
    float u = fade(samplePoint.x);
    float v = fade(samplePoint.y);
    int A = perm[X] + Y;
    int B = perm[X + 1] + Y;
    return lerp(v, lerp(u, perlin_grad(perm[A & 511], samplePoint.x, samplePoint.y), perlin_grad(perm[B & 511], samplePoint.x - 1, samplePoint.y)),
                   lerp(u, perlin_grad(perm[(A + 1) & 511], samplePoint.x, samplePoint.y - 1), perlin_grad(perm[(B + 1) & 511], samplePoint.x - 1, samplePoint.y - 1)));
}


float2 get_grad_vector_matched(int hash)
{
    int h = hash & 15;
    // Diese Logik spiegelt exakt wider, welche Vektoren aus der
    // Kombination von u, v, x und y in der Originalfunktion entstehen.
    switch (h)
    {
        case 0:
            return float2(1, 1);
        case 1:
            return float2(-1, 1);
        case 2:
            return float2(1, -1);
        case 3:
            return float2(-1, -1);
        case 4:
            return float2(1, 0);
        case 5:
            return float2(-1, 0);
        case 6:
            return float2(1, 0); // Ja, Duplikate sind hier korrekt
        case 7:
            return float2(-1, 0);
        case 8:
            return float2(0, 1);
        case 9:
            return float2(0, -1);
        case 10:
            return float2(0, 1);
        case 11:
            return float2(0, -1);
        case 12:
            return float2(1, 1);
        case 13:
            return float2(-1, 1);
        case 14:
            return float2(1, -1);
        case 15:
            return float2(-1, -1);
    }
    return float2(0, 0); // Sollte nie erreicht werden
}

float3 perlinNoise_and_Deriv(float2 samplePoint)
{
    // 1. Gitterzelle und lokale Koordinaten finden
    float2 fp = floor(samplePoint);
    int2 ip = int2(fp);
    float2 sp = samplePoint - fp; // Lokale Koordinaten (sx, sy)

    // 2. Hashes für die 4 Eckpunkte der Zelle berechnen (MIT KORREKTEM INDEXING!)
    int X = ip.x & 255;
    int Y = ip.y & 255;
    int A = perm[X] + Y;
    int B = perm[X + 1] + Y;

    // & 511 verwenden!
    int hash00 = perm[A & 511];
    int hash10 = perm[B & 511];
    int hash01 = perm[(A + 1) & 511];
    int hash11 = perm[(B + 1) & 511];

    // 3. Gradientenvektoren für alle 4 Ecken holen
    float2 grad00 = get_grad_vector_matched(hash00);
    float2 grad10 = get_grad_vector_matched(hash10);
    float2 grad01 = get_grad_vector_matched(hash01);
    float2 grad11 = get_grad_vector_matched(hash11);

    // 4. Einflusswerte (Skalarprodukte) berechnen
    float val00 = dot(grad00, sp);
    float val10 = dot(grad10, sp - float2(1.0, 0.0));
    float val01 = dot(grad01, sp - float2(0.0, 1.0));
    float val11 = dot(grad11, sp - float2(1.0, 1.0));

    // 5. Interpolationsgewichte und deren Ableitungen berechnen
    float u = fade(sp.x);
    float v = fade(sp.y);
    float dudx = fade_deriv(sp.x);
    float dvdy = fade_deriv(sp.y);

    // 6. Den Noise-Wert per bilinearer Interpolation berechnen
    float value = lerp(v, lerp(u, val00, val10), lerp(u, val01, val11));

    // 7. Die Ableitung zusammensetzen (analytisch korrekt)
    // Partielle Ableitung nach x
    float k0 = val10 - val00;
    float k1 = val11 - val01;
    float kx_part1 = dudx * lerp(v, k0, k1);
    float kx_part2 = lerp(v, lerp(u, grad00.x, grad10.x), lerp(u, grad01.x, grad11.x));
    
    // Partielle Ableitung nach y
    float k3 = lerp(u, val01, val11);
    float k4 = lerp(u, val00, val10);
    float ky_part1 = dvdy * (k3 - k4);
    float ky_part2 = lerp(v, lerp(u, grad00.y, grad10.y), lerp(u, grad01.y, grad11.y));
    
    float2 derivative = float2(kx_part1 + kx_part2, ky_part1 + ky_part2);
    return float3(value, derivative.x, derivative.y);
}

#endif