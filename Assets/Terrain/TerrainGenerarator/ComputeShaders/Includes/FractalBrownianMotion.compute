#ifndef FRACTAL_BROWNIAN_MOTION_INCLUDED
#define FRACTAL_BROWNIAN_MOTION_INCLUDED

#define PERLIN         0
#define SIMPLEX        1
#define VALUE          2

#include "PerlinNoise.compute"
#include "SimplexNoise.compute"
#include "ValueNoise.compute"

/// <summary>
/// Wandelt eine normale Noise-Probe (Wert im Bereich [-1, 1]) in eine "Ridged"-Probe um,
/// die ebenfalls im Bereich [-1, 1] liegt, basierend auf der Formel (abs(wert) - 0.5) * 2.
/// </summary>
/**
float3 ToRidged(float3 noiseSample)
{
    float ridgedValue = (abs(noiseSample.x) - 0.5) * 2.0;

    float2 ridgedDerivative = sign(noiseSample.x) * noiseSample.yz * 2.0;

    return float3(ridgedValue, ridgedDerivative);
}
**/

/// <summary>
/// Führt eine glatte Invertierung einer Noise-Probe durch (erzeugt weiche Täler).
/// Der Wertebereich von [-1, 1] wird auf [0, 1] abgebildet.
/// Die Ableitung bleibt stetig.
/// </summary>
float3 ToSmoothInverted(float3 noiseSample)
{
    float value = noiseSample.x;
    float2 derivative = noiseSample.yz;

    // 1. Die glatte Invertierungsfunktion: 1 - x^2
    float invertedValue = 1.0 - value * value;

    // 2. Die Ableitung mit der Kettenregel: d/dp(1 - f(p)^2) = -2 * f(p) * f'(p)
    float2 invertedDerivative = -2.0 * value * derivative;

    return float3(invertedValue, invertedDerivative);
}


// --- Modifiziertes FBM (nach Inigo Quilez) ---
float AdvancedFBM(float2 samplePoint, in FbmParams params)
{
    float heightValue = 0.0;
    float amplitude = 1.0;
    float2 accumulatedDerivative = float2(0.0, 0.0);

    for (int i = 0; i < params.octaves; i++)
    {
        float3 noise_deriv;
        if (params.noiseType == VALUE)
            noise_deriv = valueNoise_deriv(samplePoint);
        else if (params.noiseType == SIMPLEX)
            noise_deriv = simplexNoise_deriv(samplePoint);
        else
            noise_deriv = perlinNoise_deriv(samplePoint);
        
        if (i < params.ridgedOctaves && i > 0)
        {
            noise_deriv = ToSmoothInverted(noise_deriv);

        }

        accumulatedDerivative += amplitude * noise_deriv.yz;

        heightValue += amplitude * noise_deriv.x / (1.0 + dot(accumulatedDerivative, accumulatedDerivative));
        
        amplitude *= params.persistence;
        float2 rotatedPoint = float2(
            samplePoint.x * 0.8 + samplePoint.y * 0.6,
            samplePoint.x * -0.6 + samplePoint.y * 0.8
        );
        
        samplePoint = rotatedPoint * params.lacunarity;
    }

    return heightValue * 0.5 + 0.5;
}


// --- Standard Fractional Brownian Motion ---
float StandardFBM(float2 samplePoint, in FbmParams params)
{
    float totalValue = 0;
    float frequency = 1.0;
    float amplitude = 1.0;
    float maxAmplitude = 0.0;

    for (int i = 0; i < params.octaves; i++)
    {
        float noiseValue;
        if (params.noiseType == SIMPLEX) 
            noiseValue = simplexNoise(samplePoint * frequency);
        else if (params.noiseType == VALUE) 
            noiseValue = valueNoise_deriv(samplePoint * frequency).x;
        else
            noiseValue = perlinNoise(samplePoint * frequency);
        
        if (i < params.ridgedOctaves)
        {
            noiseValue = (abs(noiseValue) - 0.5) * 2;

        }
        
        totalValue += noiseValue * amplitude;
        maxAmplitude += amplitude;
        amplitude *= params.persistence;
        frequency *= params.lacunarity;
    }
    
    return (totalValue / maxAmplitude) * 0.5 + 0.5;
}

#endif